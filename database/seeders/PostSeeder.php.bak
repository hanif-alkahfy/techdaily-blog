<?php

namespace Database\Seeders;

use App\Models\Post;
use App\Models\User;
use App\Models\Category;
use Illuminate\Database\Console\Seeds\WithoutModelEvents;
use Illuminate\Database\Seeder;

class PostSeeder extends Seeder
{
    /**
     * Run the database seeds.
     */
    public function run(): void
    {
        // Ensure we have at least one user
        if (User::count() === 0) {
            User::factory()->create([
                'name' => 'Admin User',
                'email' => 'admin@techdaily.com',
            ]);
        }

        // Get admin user
        $admin = User::where('email', 'admin@techdaily.com')->first();

        if (!$admin) {
            $admin = User::factory()->create([
                'name' => 'Admin User',
                'email' => 'admin@techdaily.com',
                'is_admin' => true
            ]);
        }

        // Create posts with real content
        $this->createRealPosts($admin);

        $this->command->info('Created ' . Post::count() . ' posts with real content');
    }

    /**
     * Create posts based on real content from various platforms
     */
    /**
     * Get relevant tags from content
     */
    private function getRelevantTags(string $content, string $category): array
    {
        $commonTags = [
            'Tutorial' => ['tutorial', 'guide', 'howto', 'learn', 'step-by-step'],
            'Web Development' => ['web', 'development', 'frontend', 'backend', 'fullstack'],
            'Opinion' => ['opinion', 'thoughts', 'perspective', 'analysis', 'insights'],
            'Review' => ['review', 'comparison', 'versus', 'pros-cons', 'benchmark'],
            'News' => ['news', 'announcement', 'release', 'update', 'latest'],
            'Tips' => ['tips', 'tricks', 'best-practices', 'optimization', 'productivity']
        ];

        // Get common tags for the category
        $tags = $commonTags[$category] ?? [];

        // Extract technology names mentioned in content
        $techKeywords = [
            'Laravel', 'PHP', 'JavaScript', 'Vue.js', 'React', 'TypeScript',
            'Docker', 'MySQL', 'Redis', 'Git', 'AWS', 'DevOps',
            'API', 'REST', 'GraphQL', 'Node.js', 'Python', 'Java',
            'HTML', 'CSS', 'Tailwind', 'Bootstrap', 'jQuery', 'Angular'
        ];

        foreach ($techKeywords as $tech) {
            if (stripos($content, $tech) !== false) {
                $tags[] = strtolower(str_replace(['.', ' '], ['', '-'], $tech));
            }
        }

        // Add programming-related terms if found
        $programmerTerms = ['code', 'programming', 'software', 'developer', 'engineer'];
        foreach ($programmerTerms as $term) {
            if (stripos($content, $term) !== false) {
                $tags[] = $term;
            }
        }

        // Remove duplicates and return
        return array_unique(array_filter($tags));
    }

    /**
     * Get featured image path from storage based on content
     */
    private function getFeaturedImage(array $postData): string
    {
        $storagePath = storage_path('app/public/posts/featured');

        // Create directories if they don't exist
        if (!file_exists($storagePath)) {
            mkdir($storagePath, 0755, true);
        }

        // Supported image extensions
        $extensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];

        // Define image mappings based on category and content keywords
        $imageMap = [
            'laravel' => ['laravel-*', 'php-*'],
            'php' => ['php-*', 'programming-*'],
            'docker' => ['docker-*', 'devops-*'],
            'vue' => ['vue-*', 'frontend-*'],
            'react' => ['react-*', 'frontend-*'],
            'javascript' => ['javascript-*', 'frontend-*'],
            'tailwind' => ['tailwind-*', 'css-*'],
            'bootstrap' => ['bootstrap-*', 'css-*'],
            'git' => ['git-*', 'version-control-*'],
            'api' => ['api-*', 'backend-*'],
            'database' => ['database-*', 'backend-*']
        ];

        // Get category and content for matching
        $category = strtolower($postData['category']);
        $content = strtolower($postData['content']);
        $title = strtolower($postData['title']);

        // Build array of possible image patterns
        $patterns = [];

        // Add category-specific patterns
        $patterns[] = $category . '-*.jpg';

        // Check content for keywords and add relevant patterns
        foreach ($imageMap as $keyword => $possiblePatterns) {
            if (str_contains($content, $keyword) || str_contains($title, $keyword)) {
                $patterns = array_merge($patterns, $possiblePatterns);
            }
        }

        // Find matching images
        $matchingImages = [];
        foreach ($patterns as $pattern) {
            $found = glob($storagePath . '/' . $pattern);
            if (!empty($found)) {
                $matchingImages = array_merge($matchingImages, $found);
            }
        }

        // If no specific matches found, try category fallback
        if (empty($matchingImages)) {
            $fallbackPattern = $storagePath . '/' . $category . '-*.jpg';
            $matchingImages = glob($fallbackPattern);
        }

        // If still no matches, use any available image
        if (empty($matchingImages)) {
            $matchingImages = glob($storagePath . '/*.*');
        }

        // If no images at all, create and use default
        if (empty($matchingImages)) {
            $placeholder = public_path('images/post-placeholder.jpg');
            if (!file_exists($placeholder)) {
                file_put_contents($placeholder, 'Placeholder Image');
            }

            $destPath = $storagePath . '/default.jpg';
            copy($placeholder, $destPath);
            $matchingImages = [$destPath];
        }

        // Get most relevant image (first match) or random from matches
        $selectedImage = $matchingImages[0];
        if (count($matchingImages) > 1) {
            $selectedImage = $matchingImages[array_rand($matchingImages)];
        }

        // Make path relative to storage
        return str_replace(storage_path('app/public/'), '', $selectedImage);
    }    private function createRealPosts($admin): void
    {
        $baseDate = now()->subMonths(2);
        $dayIncrement = 0;
        $realPosts = [
            // Tutorial Category
            [
                'title' => 'Building a REST API with Laravel 10: Complete Guide',
                'category' => 'Tutorial',
                'status' => 'published',
                'excerpt' => 'Learn how to build a complete REST API using Laravel 10 with authentication, validation, and proper error handling.',
                'content' => 'Laravel 10 makes building REST APIs incredibly straightforward. In this comprehensive guide, we\'ll walk through creating a complete API from scratch.

## Setting Up the Project

First, create a new Laravel project:
```bash
composer create-project laravel/laravel api-project
cd api-project
```

## Creating Models and Migrations

We\'ll start by creating our models. For this example, we\'ll build a simple blog API:
```bash
php artisan make:model Post -m
php artisan make:model Category -m
```

## API Routes and Controllers

Laravel\'s API resource controllers make it easy to handle CRUD operations:
```bash
php artisan make:controller Api/PostController --api
```

Define your API routes in `routes/api.php`:
```php
Route::apiResource(\'posts\', PostController::class);
```

## Authentication with Sanctum

Laravel Sanctum provides a simple authentication system for APIs:
```bash
composer require laravel/sanctum
php artisan vendor:publish --provider="Laravel\Sanctum\SanctumServiceProvider"
```

## Validation and Error Handling

Always validate incoming data and provide meaningful error messages:
```php
public function store(Request $request)
{
    $validated = $request->validate([
        \'title\' => \'required|string|max:255\',
        \'content\' => \'required|string\',
    ]);

    return Post::create($validated);
}
```

This foundation will give you a robust, secure API that follows Laravel best practices.',
                'source' => 'Inspired by Dev.to community posts',
            ],
            [
                'title' => 'Docker for PHP Development: Complete Setup Guide',
                'category' => 'Tutorial',
                'status' => 'published',
                'excerpt' => 'Set up a complete Docker development environment for PHP applications with MySQL, Redis, and proper volume mounting.',
                'content' => 'Docker revolutionizes PHP development by providing consistent environments across different machines. Here\'s how to set up a complete development stack.

## Why Docker for PHP?

Docker eliminates "it works on my machine" problems by containerizing your entire development environment. This ensures consistency across development, staging, and production environments.

## Basic Docker Compose Setup

Create a `docker-compose.yml` file:
```yaml
version: \'3.8\'
services:
  app:
    build: .
    volumes:
      - .:/var/www/html
    ports:
      - "8000:8000"

  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: laravel
    volumes:
      - mysql_data:/var/lib/mysql
    ports:
      - "3306:3306"

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"

volumes:
  mysql_data:
```

## Creating the Dockerfile

Your `Dockerfile` should include all necessary PHP extensions:
```dockerfile
FROM php:8.2-fpm

RUN apt-get update && apt-get install -y \
    git \
    zip \
    unzip \
    && docker-php-ext-install pdo_mysql

COPY . /var/www/html
WORKDIR /var/www/html

RUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer
```

## Running the Environment

Start your development environment:
```bash
docker-compose up -d
docker-compose exec app composer install
docker-compose exec app php artisan migrate
```

This setup provides a complete, isolated development environment that your entire team can use consistently.',
                'source' => 'Based on Docker Hub documentation and community best practices',
            ],

            // Opinion Category
            [
                'title' => 'Why I Still Choose Vue.js Over React in 2024',
                'category' => 'Opinion',
                'status' => 'published',
                'excerpt' => 'After working with both frameworks extensively, here\'s why Vue.js continues to be my go-to choice for frontend development.',
                'content' => 'The JavaScript framework debate continues to rage on, but after five years of working with both Vue.js and React, I still find myself reaching for Vue. Here\'s why.

## Learning Curve and Developer Experience

Vue\'s learning curve is significantly gentler than React\'s. New developers can be productive with Vue in days, not weeks. The single-file component structure feels intuitive, and the template syntax is familiar to anyone who\'s worked with HTML.

React, with its JSX and functional programming concepts, requires a more significant mental shift. While powerful, it can be overwhelming for newcomers.

## Documentation and Community

Vue\'s documentation is exceptional. It\'s comprehensive, well-organized, and includes practical examples. The Vue team clearly prioritizes developer experience in their documentation.

React\'s documentation has improved significantly, but Vue still leads in this area.

## Bundle Size and Performance

Out of the box, Vue produces smaller bundle sizes. Vue 3\'s composition API provides React-like capabilities while maintaining Vue\'s template-driven approach.

Vue\'s reactivity system is also more efficient for many use cases, automatically optimizing re-renders without requiring manual optimization like React\'s useMemo and useCallback.

## Ecosystem Maturity

While React has a larger ecosystem, Vue\'s ecosystem is more curated. Tools like Nuxt.js, Pinia, and Vue Router provide official or semi-official solutions that work seamlessly together.

React\'s vast ecosystem can be overwhelming, with multiple competing solutions for the same problems.

## The Bottom Line

Both frameworks are excellent choices, but Vue\'s balance of power and simplicity continues to make it my preferred option for most projects. Your mileage may vary, but don\'t overlook Vue in the React-dominated discussion.',
                'source' => 'Personal opinion piece inspired by Medium discussions',
            ],
            [
                'title' => 'The Death of jQuery: Why It\'s Finally Time to Move On',
                'category' => 'Opinion',
                'status' => 'published',
                'excerpt' => 'jQuery served us well for over a decade, but modern JavaScript and frameworks have made it obsolete. Here\'s why it\'s time to let go.',
                'content' => 'jQuery revolutionized web development when it launched in 2006. It solved real problems: inconsistent browser APIs, verbose DOM manipulation, and lack of modern JavaScript features. But in 2024, it\'s time to admit that jQuery\'s time has passed.

## What jQuery Solved

jQuery addressed genuine pain points in web development:
- Cross-browser compatibility issues
- Verbose DOM manipulation
- AJAX request handling
- Animation and effects
- Event handling inconsistencies

These were real problems in the IE6-IE8 era, and jQuery provided elegant solutions.

## Why jQuery Is No Longer Needed

Modern browsers have converged on web standards. The APIs that jQuery abstracted are now consistent across browsers:

- `document.querySelectorAll()` replaced jQuery selectors
- `fetch()` API replaced jQuery\'s AJAX methods
- CSS3 animations replaced jQuery animations
- Modern JavaScript (ES6+) provides cleaner syntax

## The Performance Cost

jQuery adds ~30KB to your bundle size. For many applications, you\'re shipping a library just to use `$(\'#element\')` instead of `document.getElementById(\'element\')`.

Modern bundlers and tree-shaking can\'t eliminate unused jQuery code effectively because of its monolithic structure.

## Learning Modern JavaScript

Relying on jQuery prevents developers from learning modern JavaScript. Understanding the platform APIs makes you a better developer and enables you to work with any framework or library.

## Migration Strategy

Migrating from jQuery doesn\'t have to be painful:
1. Replace jQuery selectors with native DOM methods
2. Use fetch() for AJAX requests
3. Replace jQuery animations with CSS transitions
4. Use modern event handling

## Conclusion

jQuery was a necessary bridge between old and new web development. That bridge has served its purpose. Modern JavaScript is powerful, consistent, and well-supported. It\'s time to embrace the platform.',
                'source' => 'Inspired by discussions on Hacker News and dev communities',
            ],

            // Review Category
            [
                'title' => 'Tailwind CSS vs Bootstrap 5: A Comprehensive Comparison',
                'category' => 'Review',
                'status' => 'published',
                'excerpt' => 'An in-depth comparison of the two most popular CSS frameworks, covering everything from design philosophy to performance.',
                'content' => 'The CSS framework landscape has been dominated by Bootstrap for years, but Tailwind CSS has emerged as a serious contender. After using both extensively, here\'s my comprehensive comparison.

## Design Philosophy

**Bootstrap** follows a component-based approach. You get pre-built components like buttons, cards, and navbars that you can customize through SASS variables and custom CSS.

**Tailwind CSS** takes a utility-first approach. Instead of pre-built components, you compose designs using small, single-purpose utility classes.

## Learning Curve

**Bootstrap (★★★★☆)**: Easier for beginners. The component-based approach feels familiar, and you can build decent-looking sites quickly.

**Tailwind CSS (★★★☆☆)**: Steeper initial learning curve. You need to learn utility class names, but once you do, development becomes very fast.

## Customization

**Bootstrap (★★★☆☆)**: Customization often requires overriding CSS, which can lead to specificity battles. SASS customization helps but has limitations.

**Tailwind CSS (★★★★★)**: Extremely customizable through configuration files. You can customize everything from colors to spacing scales without writing custom CSS.

## Bundle Size

**Bootstrap (★★★☆☆)**: Larger bundle size (~25KB minified + gzipped) even with unused components. Purging unused CSS requires additional tooling.

**Tailwind CSS (★★★★☆)**: Larger development build but excellent production optimization. With PurgeCSS, production builds are typically smaller than Bootstrap.

## Development Speed

**Bootstrap (★★★★☆)**: Very fast for prototyping and standard designs. Component-based approach accelerates development.

**Tailwind CSS (★★★★★)**: Once familiar with utilities, development is extremely fast. No context switching between HTML and CSS files.

## Design Uniqueness

**Bootstrap (★★☆☆☆)**: Sites tend to look similar without significant customization. The "Bootstrap look" is recognizable.

**Tailwind CSS (★★★★★)**: Encourages unique designs. Utility-first approach makes it easy to create custom looks.

## Community and Ecosystem

**Bootstrap (★★★★★)**: Massive ecosystem with themes, templates, and third-party components. Extensive documentation and community.

**Tailwind CSS (★★★★☆)**: Growing rapidly. Headless UI, Tailwind UI, and many component libraries available. Excellent documentation.

## Verdict

Choose **Bootstrap** if:
- You need to prototype quickly
- Your team prefers component-based approaches
- You\'re building standard business applications

Choose **Tailwind CSS** if:
- You want maximum design flexibility
- You prefer utility-first approaches
- Bundle size optimization is important
- You want to avoid "framework look"

Both are excellent choices, but Tailwind CSS represents the future of CSS frameworks.',
                'source' => 'Based on extensive usage and community feedback from Reddit and dev forums',
            ],
            [
                'title' => 'Reviewing the Top 5 PHP IDEs in 2024',
                'category' => 'Review',
                'status' => 'published',
                'excerpt' => 'A detailed review of the best IDEs and editors for PHP development, comparing features, performance, and value.',
                'content' => 'Choosing the right IDE can significantly impact your PHP development productivity. After testing the top options extensively, here\'s my comprehensive review.

## 1. PhpStorm (★★★★★)

**Price**: $199/year (first year), $159/year (second year), $119/year (third year onwards)

**Pros**:
- Exceptional PHP intellisense and code analysis
- Built-in debugging with Xdebug integration
- Excellent database tools
- Git integration and version control
- Framework support (Laravel, Symfony, WordPress)
- Refactoring tools
- Built-in terminal and SSH support

**Cons**:
- Expensive for individual developers
- Can be resource-heavy
- Learning curve for advanced features

**Best for**: Professional PHP developers, large teams, complex applications

## 2. Visual Studio Code (★★★★☆)

**Price**: Free

**Pros**:
- Completely free and open-source
- Lightweight and fast
- Massive extension ecosystem
- Great Git integration
- Excellent debugging support with extensions
- Cross-platform consistency
- Regular updates

**Cons**:
- Requires extensions for full PHP functionality
- Can become slow with too many extensions
- Less intelligent code analysis than PhpStorm

**Best for**: Developers on a budget, those who prefer customizable environments

## 3. Sublime Text (★★★☆☆)

**Price**: $99 one-time license

**Pros**:
- Extremely fast and lightweight
- Powerful search and replace
- Multiple cursors and selections
- Package ecosystem
- Distraction-free interface

**Cons**:
- Limited built-in PHP features
- Requires packages for modern functionality
- Less active development than competitors

**Best for**: Developers who prioritize speed and simplicity

## 4. Vim/Neovim (★★★☆☆)

**Price**: Free

**Pros**:
- Ultimate customization
- Extremely lightweight
- Available on all platforms
- Powerful once mastered
- Never leaves keyboard

**Cons**:
- Steep learning curve
- Requires significant configuration
- Not beginner-friendly

**Best for**: Power users, terminal-focused developers

## 5. NetBeans (★★★☆☆)

**Price**: Free

**Pros**:
- Free and open-source
- Good PHP support out of the box
- Integrated development environment
- Project management features

**Cons**:
- Slower than alternatives
- Less modern interface
- Smaller community

**Best for**: Developers wanting a free full IDE experience

## Conclusion

For professional PHP development, PhpStorm remains the gold standard despite its cost. VS Code offers the best balance of features and price for most developers. Choose based on your budget, team requirements, and complexity of projects.',
                'source' => 'Personal testing and community feedback from Stack Overflow surveys',
            ],

            // News Category
            [
                'title' => 'PHP 8.3 Released: New Features and Improvements',
                'category' => 'News',
                'status' => 'published',
                'excerpt' => 'PHP 8.3 brings exciting new features including typed class constants, readonly amendments, and performance improvements.',
                'content' => 'The PHP development team has released PHP 8.3, bringing several exciting new features and improvements that will enhance developer productivity and application performance.

## Key New Features

### Typed Class Constants

PHP 8.3 introduces the ability to declare types for class constants:

```php
class Status {
    public const string PENDING = \'pending\';
    public const string COMPLETED = \'completed\';
    public const int MAX_RETRIES = 3;
}
```

This provides better type safety and clearer code documentation.

### Readonly Amendments

The readonly functionality has been expanded with new capabilities:

```php
readonly class User {
    public function __construct(
        public string $name,
        public string $email,
    ) {}
}
```

### Dynamic Class Constant Fetch

You can now fetch class constants dynamically:

```php
$constantName = \'STATUS_ACTIVE\';
$value = MyClass::{$constantName};
```

### New json_validate() Function

A dedicated function for JSON validation without parsing:

```php
if (json_validate($jsonString)) {
    $data = json_decode($jsonString);
}
```

## Performance Improvements

PHP 8.3 includes several performance optimizations:
- Improved opcache performance
- Better memory usage in specific scenarios
- Faster array operations

## Deprecations and Changes

Several features have been deprecated in preparation for PHP 9.0:
- Passing negative string offsets to certain functions
- Using ${} for variable parsing in strings
- Various legacy functionalities

## Migration Considerations

Most PHP 8.2 applications should run on PHP 8.3 without issues. However, developers should:
- Test applications thoroughly
- Review deprecated feature usage
- Update dependencies that may be affected

## Community Response

The PHP community has responded positively to these changes, particularly appreciating the continued focus on type safety and performance improvements.

PHP 8.3 represents another solid step forward for the language, maintaining backward compatibility while introducing useful new features.',
                'source' => 'Official PHP release notes and community discussions',
            ],
            [
                'title' => 'GitHub Copilot Chat Now Available in IDE',
                'category' => 'News',
                'status' => 'published',
                'excerpt' => 'GitHub announces the general availability of Copilot Chat, bringing conversational AI assistance directly to your development environment.',
                'content' => 'GitHub has announced the general availability of GitHub Copilot Chat, extending the AI-powered coding assistant with conversational capabilities directly within supported IDEs.

## What\'s New

GitHub Copilot Chat builds upon the existing Copilot code completion by adding:

### Conversational Interface
- Natural language queries about your code
- Context-aware responses based on your current project
- Ability to ask for explanations, refactoring suggestions, and debugging help

### IDE Integration
Currently supported in:
- Visual Studio Code (with GitHub Copilot extension)
- Visual Studio 2022
- JetBrains IDEs (IntelliJ IDEA, PhpStorm, etc.)

### Enhanced Capabilities
- **Code Explanation**: Ask Copilot to explain complex code blocks
- **Refactoring Suggestions**: Get recommendations for improving code structure
- **Bug Detection**: Identify potential issues in your code
- **Test Generation**: Generate unit tests for your functions
- **Documentation**: Create documentation for your code

## Example Use Cases

Developers can now:
- Ask "What does this function do?" while viewing unfamiliar code
- Request "Refactor this method to be more readable"
- Query "Write unit tests for this class"
- Get help with "Fix the bug in this code"

## Pricing and Availability

GitHub Copilot Chat is included with existing GitHub Copilot subscriptions:
- Individual: $10/month or $100/year
- Business: $19/user/month

## Developer Reception

Early feedback from developers has been overwhelmingly positive:
- Reduced time spent on documentation lookup
- Faster debugging and troubleshooting
- Better code understanding for team collaboration
- Improved learning curve for new technologies

## Privacy and Security

GitHub maintains that:
- Code snippets are not stored permanently
- Conversations are not used to train models without consent
- Enterprise customers have additional privacy controls

## Looking Ahead

GitHub plans to expand Copilot Chat with:
- Support for more IDEs
- Integration with pull request reviews
- Team collaboration features
- Custom model training for organizations

This represents a significant step toward more interactive and intelligent development environments, potentially changing how developers interact with their tools and learn new technologies.',
                'source' => 'GitHub official announcements and developer community feedback',
            ],

            // Tips Category
            [
                'title' => '10 Laravel Performance Tips Every Developer Should Know',
                'category' => 'Tips',
                'status' => 'published',
                'excerpt' => 'Essential performance optimization techniques to make your Laravel applications faster and more efficient.',
                'content' => 'Laravel applications can be incredibly performant when optimized correctly. Here are 10 essential tips to boost your Laravel app\'s performance.

## 1. Use Eager Loading to Avoid N+1 Queries

The N+1 query problem is one of the most common performance issues:

```php
// Bad - N+1 queries
$posts = Post::all();
foreach ($posts as $post) {
    echo $post->user->name; // Queries database for each post
}

// Good - Eager loading
$posts = Post::with(\'user\')->get();
foreach ($posts as $post) {
    echo $post->user->name; // Uses loaded data
}
```

## 2. Implement Query Result Caching

Cache expensive database queries:

```php
$users = Cache::remember(\'users\', 3600, function () {
    return User::with(\'profile\')->get();
});
```

## 3. Use Database Indexing

Add indexes to frequently queried columns:

```php
Schema::table(\'posts\', function (Blueprint $table) {
    $table->index([\'user_id\', \'created_at\']);
    $table->index(\'slug\');
});
```

## 4. Optimize Composer Autoloader

Use optimized autoloader in production:

```bash
composer install --optimize-autoloader --no-dev
```

## 5. Enable OPcache

Configure OPcache in production environments:

```ini
opcache.enable=1
opcache.memory_consumption=256
opcache.max_accelerated_files=20000
opcache.validate_timestamps=0
```

## 6. Use Select Specific Columns

Don\'t load unnecessary data:

```php
// Bad - loads all columns
$users = User::all();

// Good - only loads needed columns
$users = User::select(\'id\', \'name\', \'email\')->get();
```

## 7. Implement Route Caching

Cache your routes in production:

```bash
php artisan route:cache
```

## 8. Use Queue Workers for Heavy Tasks

Move time-consuming tasks to queues:

```php
// Instead of processing immediately
Mail::to($user)->send(new WelcomeEmail());

// Queue the job
Mail::to($user)->queue(new WelcomeEmail());
```

## 9. Optimize Configuration Loading

Cache configuration in production:

```bash
php artisan config:cache
php artisan view:cache
```

## 10. Use Pagination for Large Datasets

Don\'t load all records at once:

```php
// Bad - loads everything
$posts = Post::all();

// Good - paginated results
$posts = Post::paginate(15);

// Even better - cursor pagination for large datasets
$posts = Post::cursorPaginate(15);
```

## Bonus: Monitor Performance

Use Laravel Debugbar in development and monitoring tools like New Relic or Blackfire in production to identify bottlenecks.

Implementing these tips can dramatically improve your Laravel application\'s performance, providing better user experience and reducing server costs.',
                'source' => 'Laravel community best practices and official documentation',
            ],
            [
                'title' => '5 Git Commands Every Developer Should Master',
                'category' => 'Tips',
                'status' => 'published',
                'excerpt' => 'Beyond the basics: advanced Git commands that will improve your development workflow and save you time.',
                'content' => 'Most developers know the basic Git commands, but mastering these advanced commands will significantly improve your workflow and productivity.

## 1. git rebase -i (Interactive Rebase)

Clean up your commit history before merging:

```bash
git rebase -i HEAD~3
```

This opens an interactive editor where you can:
- **pick**: Keep the commit as-is
- **reword**: Change the commit message
- **squash**: Combine with previous commit
- **drop**: Remove the commit entirely

Example workflow:
```bash
# Clean up last 3 commits
git rebase -i HEAD~3

# In the editor:
pick abc123f Add user authentication
squash def456g Fix typo in auth
squash ghi789h Update tests
```

Results in a single, clean commit with all changes.

## 2. git bisect (Binary Search for Bugs)

Find the exact commit that introduced a bug:

```bash
# Start bisecting
git bisect start

# Mark current commit as bad
git bisect bad

# Mark a known good commit
git bisect good v1.2.0

# Git will checkout commits for you to test
# Mark each as good or bad
git bisect good  # or git bisect bad

# When found, reset
git bisect reset
```

This uses binary search to quickly identify problematic commits in large codebases.

## 3. git stash (Advanced Usage)

Save and manage temporary changes:

```bash
# Stash with a message
git stash push -m "Work in progress on user profiles"

# Stash only specific files
git stash push -m "Partial changes" file1.js file2.css

# List all stashes
git stash list

# Apply specific stash without removing it
git stash apply stash@{1}

# Pop specific stash (apply and remove)
git stash pop stash@{1}

# Create a branch from a stash
git stash branch feature-branch stash@{0}
```

## 4. git cherry-pick (Selective Commit Application)

Apply specific commits from other branches:

```bash
# Pick a single commit
git cherry-pick abc123f

# Pick multiple commits
git cherry-pick abc123f def456g

# Pick a range of commits
git cherry-pick abc123f..ghi789h

# Pick without committing (for modifications)
git cherry-pick --no-commit abc123f
```

Perfect for applying hotfixes across multiple branches or selective feature porting.

## 5. git reflog (Recovery Tool)

Recover "lost" commits and branches:

```bash
# View reflog
git reflog

# Output shows:
# abc123f HEAD@{0}: commit: Add new feature
# def456g HEAD@{1}: checkout: moving from main to feature
# ghi789h HEAD@{2}: reset: moving to HEAD~1

# Recover a reset commit
git reset --hard abc123f

# Recover a deleted branch
git checkout -b recovered-branch ghi789h
```

Reflog is your safety net - it tracks all HEAD movements for 30 days by default.

## Pro Tips for Daily Use

### Combine Commands for Efficiency
```bash
# Add all changes and commit with message
git add . && git commit -m "Your message"

# Push new branch and set upstream
git push -u origin feature-branch

# Undo last commit but keep changes
git reset HEAD~1
```

### Create Useful Aliases
```bash
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
git config --global alias.unstage \'reset HEAD --\'
git config --global alias.last \'log -1 HEAD\'
git config --global alias.visual \'!gitk\'
```

Mastering these commands will make you more efficient with Git and help you handle complex scenarios with confidence.',
                'source' => 'Git documentation and developer community best practices',
            ],
        ];

        foreach ($realPosts as $postData) {
            $created_at = $baseDate->copy()->addDays($dayIncrement);
            $dayIncrement += 2; // Add 2 days between posts for chronological spacing

            // Get or create category
            $category = Category::firstOrCreate(
                ['name' => $postData['category']],
                ['slug' => \Illuminate\Support\Str::slug($postData['category'])]
            );

            // Get featured image based on content
            $featuredImage = $this->getFeaturedImage($postData);

            Post::factory()->create([
                'title' => $postData['title'],
                'category_id' => $category->id,
                'status' => $postData['status'],
                'excerpt' => $postData['excerpt'],
                'content' => $postData['content'],
                'user_id' => $admin->id,
                'created_at' => $created_at,
                'published_at' => $created_at,
                'featured_image' => $featuredImage,
                'meta_keywords' => implode(',', array_unique([
                    $category->name,  // Category sebagai tag utama
                    ...array_filter(explode(' ', strtolower(preg_replace('/[^a-zA-Z0-9\s]/', '', $postData['title'])))), // Words dari title
                    ...$this->getRelevantTags($postData['content'], $category->name) // Tags dari content
                ])),
            ]);
        }

        $this->command->info('Created ' . count($realPosts) . ' posts from real online sources');
    }
}
